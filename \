/*
AUTORI: Onofrio de Robertis
        Michele Amato
        Davide Fornelli
        Giuliano Antoniciello

DATA INIZIO: 27/05/2024
DATA MODIFICA: 22/07/2025

NOME FILE: partita.c (versione Othello)

MODIFICHE:
- Adattato per gioco Othello
- Griglia 8x8
- Logica di flip pedine
- Controllo mosse valide
- Turni giocatore 1 (nero) e 2 (bianco)
*/

#include <stdio.h>
#include "../include/tipiDiDato.h"
#include "../include/partita.h"
#include "../include/funzioniUtilita.h"

#define DIM_OTHELLO 8
#define VUOTO 0
#define NERO 1
#define BIANCO 2

#define PICCOLA 1
#define MEDIA 2
#define GRANDE 3

// Prototipi interni
void inizializzarePartitaOthello(Partita *partita);
int mossaValida(Partita *partita, int riga, int colonna, int giocatore);
void eseguiMossa(Partita *partita, int riga, int colonna, int giocatore);
void flipPedine(Partita *partita, int riga, int colonna, int giocatore);
int pedineDaFlippareInDirezione(Partita *p, int r, int c, int dr, int dc, int g);
int nessunaMossaPossibile(Partita *partita, int giocatore);
void stampareScacchieraOthello(Partita *partita);
int contarePedine(Partita *partita, int giocatore);
void stampareVittoriaOthello(int neri, int bianchi);

// === FUNZIONE PRINCIPALE ===
void avviarePartita(char inputNome[50], int modalita, int dimensione) {
    printf("[DEBUG] avviarePartita chiamata con nome=%s, modalita=%d, dimensione=%d\n", inputNome, modalita, dimensione);
    Partita partita;
    int turno = NERO;
    int riga, colonna;
    int fine = 0;
    int neri;
    int bianchi;

    scrivereNomePartita(&partita, (char *)inputNome);
    partita.modalita = modalita;
    scrivereDimScacchieraPartita(&partita, dimensione);
    inizializzareScacchieraPartita(&partita, dimensione);

    // Posizione iniziale Othello solo se dimensione almeno 4 e pari
    if (dimensione >= 4 && dimensione % 2 == 0) {
        int mid = dimensione / 2;
        scrivereStatoScacchieraPartita(&partita, NERO, mid - 1, mid - 1);
        scrivereStatoScacchieraPartita(&partita, BIANCO, mid - 1, mid);
        scrivereStatoScacchieraPartita(&partita, BIANCO, mid, mid - 1);
        scrivereStatoScacchieraPartita(&partita, NERO, mid, mid);
    }

    pulireBuffer(); // pulisco il buffer prima di iniziare il ciclo partita

    while (!fine) {
        pulireSchermo();
        stampareScacchieraOthello(&partita);

        neri = contarePedine(&partita, NERO);
        bianchi = contarePedine(&partita, BIANCO);
        printf("\nTurno: %s   Nero: %d   Bianco: %d\n",
               (turno == NERO ? "Nero" : "Bianco"), neri, bianchi);

        if (nessunaMossaPossibile(&partita, turno)) {
            printf("Nessuna mossa disponibile per %s.\n",
                   (turno == NERO ? "Nero" : "Bianco"));
            turno = (turno == NERO) ? BIANCO : NERO;
            if (nessunaMossaPossibile(&partita, turno)) {
                fine = 1;
                break;
            }
            continue;
        }

        printf("[DEBUG] Prima di scanf per la mossa\n");
        printf("Inserisci riga e colonna (1-%d, es. 4 5): ", dimensione);
        scanf("%d %d", &riga, &colonna);
        pulireBuffer();

        if (riga < 1 || riga > dimensione || colonna < 1 || colonna > dimensione) {
            printf("Valori fuori range.\n");
            continue;
        }

        riga--; colonna--;

        if (!mossaValida(&partita, riga, colonna, turno)) {
            printf("Mossa non valida.\n");
            continue;
        }

        eseguiMossa(&partita, riga, colonna, turno);
        turno = (turno == NERO) ? BIANCO : NERO;
    }

    stampareVittoriaOthello(neri, bianchi);
}

// === INIZIALIZZAZIONE ===
void inizializzarePartitaOthello(Partita *partita) {
    scrivereDimScacchieraPartita(partita, DIM_OTHELLO);
    inizializzareScacchieraPartita(partita, DIM_OTHELLO);

    // Posizione iniziale Othello
    scrivereStatoScacchieraPartita(partita, NERO, 3, 3);
    scrivereStatoScacchieraPartita(partita, BIANCO, 3, 4);
    scrivereStatoScacchieraPartita(partita, BIANCO, 4, 3);
    scrivereStatoScacchieraPartita(partita, NERO, 4, 4);
}

// === CONTROLLO VALIDITÃ€ MOSSA ===
int mossaValida(Partita *partita, int riga, int colonna, int giocatore) {
    int dim = leggereDimScacchiera(partita->scacchieraPartita);
    if (leggereStatoScacchiera(leggereScacchieraPartita(partita), riga, colonna) != VUOTO)
        return 0;

    int dr[] = {-1, -1, -1, 0, 0, 1, 1, 1};
    int dc[] = {-1, 0, 1, -1, 1, -1, 0, 1};

    for (int i = 0; i < 8; i++) {
        if (pedineDaFlippareInDirezione(partita, riga, colonna, dr[i], dc[i], giocatore) > 0)
            return 1;
    }
    return 0;
}

// === ESECUZIONE MOSSA ===
void eseguiMossa(Partita *partita, int riga, int colonna, int giocatore) {
    scrivereStatoScacchieraPartita(partita, giocatore, riga, colonna);
    flipPedine(partita, riga, colonna, giocatore);
}

// === FLIP PEDINE ===
void flipPedine(Partita *partita, int riga, int colonna, int giocatore) {
    int dr[] = {-1, -1, -1, 0, 0, 1, 1, 1};
    int dc[] = {-1, 0, 1, -1, 1, -1, 0, 1};

    for (int i = 0; i < 8; i++) {
        int count = pedineDaFlippareInDirezione(partita, riga, colonna, dr[i], dc[i], giocatore);
        for (int j = 1; j <= count; j++) {
            int nr = riga + dr[i] * j;
            int nc = colonna + dc[i] * j;
            scrivereStatoScacchieraPartita(partita, giocatore, nr, nc);
        }
    }
}

// === CONTA PEDINE DA FLIPPARE IN UNA DIREZIONE ===
int pedineDaFlippareInDirezione(Partita *p, int r, int c, int dr, int dc, int g) {
    int dim = leggereDimScacchiera(p->scacchieraPartita);
    int avversario = (g == NERO) ? BIANCO : NERO;
    int count = 0;
    r += dr;
    c += dc;

    while (r >= 0 && r < dim && c >= 0 && c < dim) {
        int val = leggereStatoScacchiera(leggereScacchieraPartita(p), r, c);
        if (val == avversario)
            count++;
        else if (val == g)
            return count;
        else
            break;
        r += dr;
        c += dc;
    }
    return 0;
}

// === CONTROLLO FINE PARTITA ===
int nessunaMossaPossibile(Partita *partita, int giocatore) {
    int dim = leggereDimScacchiera(partita->scacchieraPartita);
    for (int r = 0; r < dim; r++)
        for (int c = 0; c < dim; c++)
            if (mossaValida(partita, r, c, giocatore))
                return 0;
    return 1;
}

// === STAMPA SCACCHIERA ===
void stampareScacchieraOthello(Partita *partita) {
    int dim = leggereDimScacchiera(partita->scacchieraPartita);
    printf("\n    ");
    for (int c = 0; c < dim; c++) printf(" %d ", c + 1);
    printf("\n   +");
    for (int c = 0; c < dim; c++) printf("---+");
    printf("\n");

    for (int r = 0; r < dim; r++) {
        printf(" %d |", r + 1);
        for (int c = 0; c < dim; c++) {
            int val = leggereStatoScacchiera(leggereScacchieraPartita(partita), r, c);
            char simbolo = (val == NERO) ? 'N' : (val == BIANCO) ? 'B' : '.';
            printf(" %c |", simbolo);
        }
        printf("\n   +");
        for (int c = 0; c < dim; c++) printf("---+");
        printf("\n");
    }
}

// === CONTA PEDINE ===
int contarePedine(Partita *partita, int giocatore) {
    int dim = leggereDimScacchiera(partita->scacchieraPartita);
    int count = 0;
    for (int r = 0; r < dim; r++)
        for (int c = 0; c < dim; c++)
            if (leggereStatoScacchiera(leggereScacchieraPartita(partita), r, c) == giocatore)
                count++;
    return count;
}

// === STAMPA VITTORIA ===
void stampareVittoriaOthello(int neri, int bianchi) {
    pulireSchermo();
    printf("\n\n");
    stampareCentrato("Partita terminata!");
    printf("\n");
    printf("Nero: %d pedine\n", neri);
    printf("Bianco: %d pedine\n", bianchi);
    if (neri > bianchi)
        stampareCentrato("Vince il NERO!");
    else if (bianchi > neri)
        stampareCentrato("Vince il BIANCO!");
    else
        stampareCentrato("PAREGGIO!");

    int input;
    tornareHomepage(&input, 20, 30);
}

void convertireDimensione(int *dimensione) {
  if(dimensione = PICCOLA){
    dimensione = 4;
  } else if(dimensione = MEDIA){
    dimensione = 8;
  } else if(dimensione = GRANDE) {
    dimensione = 16;
  }
}
